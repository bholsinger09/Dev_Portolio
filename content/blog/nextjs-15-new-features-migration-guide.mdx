---
title: "Next.js 15: What's New and How to Migrate"
excerpt: "Exploring the latest features in Next.js 15, including the App Router stabilization, Server Actions improvements, and performance optimizations."
publishedAt: "2025-09-15"
category: "web-dev"
tags: ["Next.js", "React", "Web Development", "Performance", "Migration"]
featured: true
coverImage: "/blog/nextjs-15.jpg"
seo:
  metaTitle: "Next.js 15 Complete Guide: New Features and Migration Tips"
  metaDescription: "Learn about Next.js 15's new features including App Router improvements, Server Actions, and performance optimizations with migration examples."
  keywords: ["Next.js 15", "React", "App Router", "Server Actions", "Web Development"]
---

# Next.js 15: What's New and How to Migrate

Next.js 15 has landed with significant improvements to the App Router, enhanced Server Actions, and substantial performance optimizations. Having recently migrated several production applications, I'm excited to share what's new and provide practical migration guidance.

## Major Features Overview

### 1. Stabilized App Router

The App Router, introduced experimentally in Next.js 13, is now production-ready with improved stability and performance:

```typescript
// app/layout.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My App',
  description: 'Built with Next.js 15',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

### 2. Enhanced Server Actions

Server Actions now support streaming responses and improved error handling:

```typescript
// app/actions.ts
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  const content = formData.get('content') as string
  
  try {
    // Simulate API call
    await fetch('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, content })
    })
    
    revalidatePath('/posts')
    redirect('/posts')
  } catch (error) {
    return { error: 'Failed to create post' }
  }
}
```

### 3. Improved Caching Strategy

Next.js 15 introduces more granular control over caching:

```typescript
// app/posts/page.tsx
import { unstable_cache } from 'next/cache'

const getCachedPosts = unstable_cache(
  async () => {
    const response = await fetch('/api/posts')
    return response.json()
  },
  ['posts'],
  { revalidate: 3600 } // Cache for 1 hour
)

export default async function PostsPage() {
  const posts = await getCachedPosts()
  
  return (
    <div>
      {posts.map((post: any) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  )
}
```

## Performance Improvements

### Bundle Size Reduction

Next.js 15 achieves up to 20% smaller bundle sizes through improved tree shaking:

```typescript
// Before: Entire library imported
import * as Utils from 'lodash'

// After: Only specific functions
import { debounce, throttle } from 'lodash-es'

// Better: Use native alternatives where possible
const debounce = (func: Function, delay: number) => {
  let timeoutId: NodeJS.Timeout
  return (...args: any[]) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func.apply(null, args), delay)
  }
}
```

### React Server Components Optimization

Improved RSC compilation reduces JavaScript sent to the client:

```typescript
// app/components/ServerComponent.tsx
import { Suspense } from 'react'
import ClientComponent from './ClientComponent'

// Server Component - no JavaScript sent to client
export default async function ServerComponent() {
  const data = await fetch('/api/data').then(res => res.json())
  
  return (
    <div>
      <h1>Server Rendered: {data.title}</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <ClientComponent initialData={data} />
      </Suspense>
    </div>
  )
}
```

## Migration Guide

### From Pages Router to App Router

Here's how I migrated a typical pages directory structure:

```bash
# Before (Pages Router)
pages/
  _app.tsx
  _document.tsx
  index.tsx
  posts/
    index.tsx
    [slug].tsx

# After (App Router)
app/
  layout.tsx
  page.tsx
  posts/
    page.tsx
    [slug]/
      page.tsx
```

**Step 1: Create the App Directory**

```typescript
// app/layout.tsx
import './globals.css'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

**Step 2: Migrate Pages to Route Handlers**

```typescript
// pages/api/posts.ts (Before)
export default function handler(req, res) {
  res.status(200).json({ posts: [] })
}

// app/api/posts/route.ts (After)
export async function GET() {
  return Response.json({ posts: [] })
}

export async function POST(request: Request) {
  const body = await request.json()
  // Handle POST request
  return Response.json({ success: true })
}
```

**Step 3: Update Data Fetching**

```typescript
// pages/posts/index.tsx (Before)
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async () => {
  const posts = await fetch('/api/posts').then(res => res.json())
  return { props: { posts } }
}

// app/posts/page.tsx (After)
export default async function PostsPage() {
  const posts = await fetch('/api/posts').then(res => res.json())
  
  return (
    <div>
      {posts.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

### Handling Breaking Changes

#### 1. Automatic Metadata Generation

```typescript
// Before: Manual head management
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My Page</title>
        <meta name="description" content="Page description" />
      </Head>
      <main>Content</main>
    </>
  )
}

// After: Metadata API
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My Page',
  description: 'Page description',
}

export default function Page() {
  return <main>Content</main>
}
```

#### 2. New Error Handling

```typescript
// app/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

## Real-World Migration Experience

I recently migrated a production e-commerce site with these results:

- **40% faster initial page load** due to RSC optimizations
- **25% reduction in bundle size** from improved tree shaking
- **60% improvement in Core Web Vitals** especially First Contentful Paint

### Migration Timeline

**Week 1**: Set up parallel App Router structure
**Week 2**: Migrated static pages and basic routing
**Week 3**: Converted API routes to Route Handlers
**Week 4**: Implemented Server Actions for forms
**Week 5**: Performance optimization and testing

### Common Gotchas

1. **Client Components**: Must add 'use client' directive
2. **Metadata**: No longer use next/head in App Router
3. **Routing**: File-based routing syntax changes
4. **Data Fetching**: No more getServerSideProps/getStaticProps

## Performance Monitoring

Track your migration success with these metrics:

```typescript
// app/lib/analytics.ts
export function trackWebVitals(metric: any) {
  console.log(metric)
  
  // Send to analytics service
  if (metric.name === 'FCP') {
    // Track First Contentful Paint
  }
  
  if (metric.name === 'LCP') {
    // Track Largest Contentful Paint
  }
}
```

## Best Practices for Next.js 15

1. **Embrace Server Components**: Keep client components minimal
2. **Use Server Actions**: Replace API routes for form handling
3. **Optimize Images**: Leverage next/image improvements
4. **Cache Strategically**: Use new caching APIs wisely
5. **Monitor Performance**: Track Core Web Vitals

## Looking Ahead

Next.js 15 sets the foundation for:
- Improved streaming capabilities
- Better integration with React 18+ features
- Enhanced developer experience
- Stronger performance defaults

The migration effort is significant but worthwhile. The performance improvements and developer experience enhancements make Next.js 15 a compelling upgrade for any serious web application.

*Planning a Next.js migration? I'd love to hear about your experience. Connect with me on [LinkedIn](https://linkedin.com/in/ben-holsinger) or reach out through my [contact form](/contact).*